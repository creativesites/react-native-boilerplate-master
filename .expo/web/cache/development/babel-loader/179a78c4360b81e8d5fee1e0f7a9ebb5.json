{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"C:\\\\Users\\\\winston\\\\Documents\\\\react-native-boilerplate-master\\\\node_modules\\\\react-native-d3multiline-chart\\\\utils\\\\AnimatedSVGBrush\\\\index.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Color from 'color';\nimport pick from 'lodash/pick';\nimport { listen, removeListeners } from \"../AnimatedListener\";\nvar patternReg = /^url\\(#(.+?)\\)$/;\n\nfunction extractBrush(colorOrBrush) {\n  if (colorOrBrush === 'none' || !colorOrBrush) {\n    return null;\n  }\n\n  try {\n    var matched = colorOrBrush.match(patternReg);\n\n    if (matched) {\n      return [1, matched[1]];\n    } else {\n      var _Color$rgb$array = Color(colorOrBrush).rgb().array(),\n          _Color$rgb$array2 = _slicedToArray(_Color$rgb$array, 4),\n          r = _Color$rgb$array2[0],\n          g = _Color$rgb$array2[1],\n          b = _Color$rgb$array2[2],\n          _Color$rgb$array2$ = _Color$rgb$array2[3],\n          a = _Color$rgb$array2$ === void 0 ? 1 : _Color$rgb$array2$;\n\n      return [0, r / 255, g / 255, b / 255, a];\n    }\n  } catch (err) {\n    console.warn(\"\\\"\" + colorOrBrush + \"\\\" is not a valid color or brush\");\n    return null;\n  }\n}\n\nvar fillKeys = ['fill', 'fillOpacity', 'fillRule'];\nvar strokeKeys = ['stroke', 'strokeWidth', 'strokeOpacity', 'strokeDasharray', 'strokeDashoffset', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit'];\n\nfunction getPropList(nextProps, prevProps) {\n  var propList = [];\n  fillKeys.forEach(function (name) {\n    if (nextProps.hasOwnProperty(name) || prevProps.hasOwnProperty(name)) {\n      propList.push(name);\n    }\n  });\n  strokeKeys.forEach(function (name) {\n    if (nextProps.hasOwnProperty(name) || prevProps.hasOwnProperty(name)) {\n      propList.push(name);\n    }\n  });\n  return propList;\n}\n\nvar separator = /\\s*,\\s*/;\n\nfunction getStrokeDasharray(strokeDasharray) {\n  if (typeof strokeDasharray === 'string') {\n    strokeDasharray = strokeDasharray.split(separator).map(function (dash) {\n      return +dash;\n    });\n  }\n\n  if (strokeDasharray && strokeDasharray.length === 1) {\n    strokeDasharray.push(strokeDasharray[0]);\n  }\n\n  return strokeDasharray ? _toConsumableArray(strokeDasharray) : strokeDasharray;\n}\n\nfunction getStrokeDashoffset(nextProps, prevProps) {\n  var strokeDasharray = getStrokeDasharray(nextProps.strokeDasharray) || getStrokeDasharray(prevProps.strokeDasharray);\n  return strokeDasharray ? +nextProps.strokeDashoffset || +prevProps.strokeDashoffset || 0 : null;\n}\n\nvar KEYS = ['fill', 'stroke', 'strokeDashoffset'];\nexport default function SvgBrushFix(WrappedComponent) {\n  var _temp;\n\n  return _temp = function (_Component) {\n    _inherits(_temp, _Component);\n\n    var _super = _createSuper(_temp);\n\n    function _temp(_props) {\n      var _this;\n\n      _classCallCheck(this, _temp);\n\n      _this = _super.call(this, _props);\n\n      _this.setNativeProps = function (props) {\n        props.propList = getPropList(props, _this.prevProps);\n\n        if (props.fill) {\n          props.fill = extractBrush(props.fill);\n        }\n\n        if (props.stroke) {\n          props.stroke = extractBrush(props.stroke);\n        }\n\n        if (props.updateStrokeDasharray || props.strokeDashoffset) {\n          props.strokeDasharray = getStrokeDasharray(_this.strokeDasharray.values);\n          props.strokeDashoffset = getStrokeDashoffset(props, _this.prevProps);\n        }\n\n        _this._component && _this._component.setNativeProps(props);\n      };\n\n      _this.updateCache(_props);\n\n      _this.strokeDasharray = listen(_props.strokeDasharray, function (_) {\n        return _this.setNativeProps({\n          updateStrokeDasharray: true\n        });\n      });\n      return _this;\n    }\n\n    _createClass(_temp, [{\n      key: \"updateCache\",\n      value: function updateCache(props) {\n        this.prevProps = pick(props, KEYS);\n      }\n    }, {\n      key: \"componentWillReceiveProps\",\n      value: function componentWillReceiveProps(nextProps) {\n        var _this2 = this;\n\n        this.updateCache(nextProps);\n\n        if (nextProps.strokeDasharray !== this.props.strokeDasharray) {\n          removeListeners(this.strokeDasharray);\n          this.strokeDasharray = listen(nextProps.strokeDasharray, function (_) {\n            return _this2.setNativeProps({\n              updateStrokeDasharray: true\n            });\n          });\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        removeListeners(this.strokeDasharray);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var strokeDasharray = getStrokeDasharray(this.strokeDasharray.values);\n        return React.createElement(WrappedComponent, _extends({\n          ref: function ref(component) {\n            return _this3._component = component;\n          }\n        }, this.props, {\n          strokeDasharray: strokeDasharray,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 134,\n            columnNumber: 9\n          }\n        }));\n      }\n    }]);\n\n    return _temp;\n  }(Component), _temp;\n}","map":{"version":3,"sources":["C:/Users/winston/Documents/react-native-boilerplate-master/node_modules/react-native-d3multiline-chart/utils/AnimatedSVGBrush/index.js"],"names":["React","Component","Color","pick","listen","removeListeners","patternReg","extractBrush","colorOrBrush","matched","match","rgb","array","r","g","b","a","err","console","warn","fillKeys","strokeKeys","getPropList","nextProps","prevProps","propList","forEach","name","hasOwnProperty","push","separator","getStrokeDasharray","strokeDasharray","split","map","dash","length","getStrokeDashoffset","strokeDashoffset","KEYS","SvgBrushFix","WrappedComponent","props","setNativeProps","fill","stroke","updateStrokeDasharray","values","_component","updateCache","_","component"],"mappings":"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","sourcesContent":["// @flow\r\n/**\r\n * Problem: Color props such as fill and stroke cannot be animated through setNativeProps. They can be animated through state, but setNativeProps is better\r\n * Solution: Extract brush, update propList (does not seem to do anything but to be consistent extractProps I did it anyway)\r\n */\r\nimport React, { Component } from 'react';\r\nimport Color from 'color';\r\nimport pick from 'lodash/pick';\r\n\r\nimport { listen, removeListeners } from '../AnimatedListener';\r\nimport type { AnimatedListener } from '../AnimatedListener';\r\n\r\n// https://github.com/react-native-community/react-native-svg/blob/master/lib/extract/extractBrush.js\r\nconst patternReg = /^url\\(#(.+?)\\)$/;\r\nfunction extractBrush(colorOrBrush) {\r\n  if (colorOrBrush === 'none' || !colorOrBrush) {\r\n    return null;\r\n  }\r\n  try {\r\n    let matched = colorOrBrush.match(patternReg);\r\n    // brush\r\n    if (matched) {\r\n      return [1, matched[1]];\r\n      //todo:\r\n    } else { // solid color\r\n      let [r, g, b, a = 1] = Color(colorOrBrush).rgb().array();\r\n      return [0, r / 255, g / 255, b / 255, a];\r\n    }\r\n  } catch (err) {\r\n    console.warn(`\"${colorOrBrush}\" is not a valid color or brush`);\r\n    return null;\r\n  }\r\n}\r\n\r\nconst fillKeys = ['fill', 'fillOpacity', 'fillRule'];\r\nconst strokeKeys = [\r\n  'stroke',\r\n  'strokeWidth',\r\n  'strokeOpacity',\r\n  'strokeDasharray',\r\n  'strokeDashoffset',\r\n  'strokeLinecap',\r\n  'strokeLinejoin',\r\n  'strokeMiterlimit'\r\n];\r\n\r\nfunction getPropList(nextProps, prevProps) {\r\n  let propList = [];\r\n  fillKeys.forEach(name => {\r\n    if (nextProps.hasOwnProperty(name) || prevProps.hasOwnProperty(name)) {\r\n      propList.push(name);\r\n    }\r\n  });\r\n  strokeKeys.forEach(name => {\r\n    if (nextProps.hasOwnProperty(name) || prevProps.hasOwnProperty(name)) {\r\n      propList.push(name);\r\n    }\r\n  });\r\n  return propList;\r\n}\r\n\r\nconst separator = /\\s*,\\s*/;\r\nfunction getStrokeDasharray(strokeDasharray) {\r\n  if (typeof strokeDasharray === 'string') {\r\n    strokeDasharray = strokeDasharray.split(separator).map(dash => +dash);\r\n  }\r\n  if (strokeDasharray && strokeDasharray.length === 1) {\r\n    strokeDasharray.push(strokeDasharray[0]);\r\n  }\r\n  // have to clone array to allow animation with mutable changes\r\n  return strokeDasharray ? [...strokeDasharray] : strokeDasharray;\r\n}\r\n\r\nfunction getStrokeDashoffset(nextProps, prevProps) {\r\n  const strokeDasharray =\r\n    getStrokeDasharray(nextProps.strokeDasharray) ||\r\n    getStrokeDasharray(prevProps.strokeDasharray);\r\n  return strokeDasharray\r\n    ? +nextProps.strokeDashoffset || +prevProps.strokeDashoffset || 0\r\n    : null;\r\n}\r\n\r\nconst KEYS = ['fill', 'stroke', 'strokeDashoffset'];\r\n\r\nexport default function SvgBrushFix(WrappedComponent) {\r\n  return class extends Component {\r\n    strokeDasharray: AnimatedListener;\r\n    constructor(props) {\r\n      super(props);\r\n      this.updateCache(props);\r\n      this.strokeDasharray = listen(props.strokeDasharray, _ =>\r\n        this.setNativeProps({ updateStrokeDasharray: true })\r\n      );\r\n    }\r\n    updateCache(props) {\r\n      this.prevProps = pick(props, KEYS);\r\n    }\r\n    setNativeProps = props => {\r\n      props.propList = getPropList(props, this.prevProps);\r\n      if (props.fill) {\r\n        props.fill = extractBrush(props.fill);\r\n      }\r\n      if (props.stroke) {\r\n        props.stroke = extractBrush(props.stroke);\r\n      }\r\n      if (props.updateStrokeDasharray || props.strokeDashoffset) {\r\n        props.strokeDasharray = getStrokeDasharray(\r\n          this.strokeDasharray.values\r\n        );\r\n        props.strokeDashoffset = getStrokeDashoffset(\r\n          props,\r\n          this.prevProps\r\n        );\r\n      }\r\n      this._component && this._component.setNativeProps(props);\r\n    };\r\n    componentWillReceiveProps(nextProps) {\r\n      this.updateCache(nextProps);\r\n      if (nextProps.strokeDasharray !== this.props.strokeDasharray) {\r\n        removeListeners(this.strokeDasharray);\r\n        this.strokeDasharray = listen(nextProps.strokeDasharray, _ =>\r\n          this.setNativeProps({ updateStrokeDasharray: true })\r\n        );\r\n      }\r\n    }\r\n    componentWillUnmount() {\r\n      removeListeners(this.strokeDasharray);\r\n    }\r\n    render() {\r\n      const strokeDasharray = getStrokeDasharray(\r\n        this.strokeDasharray.values\r\n      );\r\n      return (\r\n        <WrappedComponent\r\n          ref={component => (this._component = component)}\r\n          {...this.props}\r\n          strokeDasharray={strokeDasharray}\r\n        />\r\n      );\r\n    }\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}